#!/bin/bash
# tests/run_real_tests.sh - Run tests with real Neovim and LSP

set -euo pipefail

# Colors for output - consistent with Makefile
RED='\033[31m'
GREEN='\033[32m'
BLUE='\033[34m'
YELLOW='\033[33m'
CYAN='\033[36m'
RESET='\033[0m'

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

print_status() {
    local color=$1
    local prefix=$2
    local message=$3
    printf '%s[%s]%s %s\n' "$color" "$prefix" "$RESET" "$message"
}

print_info() { print_status "$BLUE" "INFO" "$1"; }
print_success() { print_status "$GREEN" "SUCCESS" "$1"; }
print_warning() { print_status "$YELLOW" "WARNING" "$1"; }
print_error() { print_status "$RED" "ERROR" "$1"; }

# Check prerequisites with detailed validation
check_prerequisites() {
    print_info "Checking prerequisites..."
    
    # Check Neovim
    if ! command -v nvim &> /dev/null; then
        print_error "Neovim is required but not found in PATH"
        print_info "Please install Neovim 0.8+ and ensure it's in your PATH"
        exit 1
    fi
    
    # Get and validate Neovim version
    local nvim_version
    nvim_version=$(nvim --version 2>/dev/null | head -n1 | grep -o 'v[0-9]\+\.[0-9]\+\.[0-9]\+' || echo "unknown")
    print_info "Found Neovim: $nvim_version"
    
    # Check if it's headless-capable
    if ! nvim --headless -c "lua print('test')" -c "qa!" >/dev/null 2>&1; then
        print_error "Neovim does not support headless mode or has configuration issues"
        exit 1
    fi
    
    # Check for Lua LSP only (simplified)
    if command -v lua-language-server &> /dev/null; then
        print_success "Found lua-language-server"
    else
        print_warning "lua-language-server not found. LSP tests will be limited."
    fi
    
    # Check plugin structure
    if [ ! -d "$PROJECT_ROOT/lua/hoverfloat" ]; then
        print_error "Plugin Lua modules not found at $PROJECT_ROOT/lua/hoverfloat"
        print_info "Make sure you're running this from the plugin root directory"
        exit 1
    fi
    
    # Check if plugin binary is built (warn but don't fail)
    local binary_path="$HOME/.local/bin/nvim-context-tui"
    if [ ! -f "$binary_path" ]; then
        print_warning "TUI binary not found at $binary_path"
        print_info "Some tests may be limited without the TUI binary"
        print_info "Run 'make install' to build the TUI binary"
    else
        print_success "TUI binary found: $binary_path"
        
        # Test if binary is executable
        if [ ! -x "$binary_path" ]; then
            print_warning "TUI binary is not executable"
            chmod +x "$binary_path" 2>/dev/null || true
        fi
    fi
    
    # Validate test files exist
    local required_test_files=(
        "$SCRIPT_DIR/test_env.lua"
        "$SCRIPT_DIR/real_unit_tests.lua"
    )
    
    for test_file in "${required_test_files[@]}"; do
        if [ ! -f "$test_file" ]; then
            print_error "Required test file not found: $test_file"
            exit 1
        fi
    done
    
    print_success "Prerequisites check completed"
}

# Create minimal test init file with comprehensive error handling
create_test_init() {
    local init_file="/tmp/hoverfloat_test_init_$$.lua"
    
    cat > "$init_file" << EOF
-- Minimal init for real testing - auto-generated by run_real_tests.sh
-- Disable user configuration to ensure clean test environment
vim.env.XDG_CONFIG_HOME = '/tmp/nvim_test_$$$'
vim.env.XDG_DATA_HOME = '/tmp/nvim_test_$$$'

-- Plugin path setup
local plugin_path = '$PROJECT_ROOT'
vim.opt.rtp:prepend(plugin_path)

-- Basic settings for testing
vim.opt.swapfile = false
vim.opt.backup = false
vim.opt.undofile = false
vim.opt.compatible = false
vim.opt.loadplugins = false  -- Disable other plugins

-- Error handling for missing modules
local function safe_require(module_name)
    local ok, result = pcall(require, module_name)
    if not ok then
        print('[WARNING] Failed to load ' .. module_name .. ': ' .. tostring(result))
        return nil
    end
    return result
end

-- Try to set up basic LSP servers if available
local function setup_lsp()
    local lspconfig = safe_require('lspconfig')
    if not lspconfig then
        print('[INFO] lspconfig not available, testing without LSP servers')
        return
    end
    
    -- Lua LSP setup with comprehensive error handling
    if vim.fn.executable('lua-language-server') == 1 then
        local lua_ok, lua_err = pcall(function()
            lspconfig.lua_ls.setup({
                settings = {
                    Lua = {
                        runtime = { version = 'LuaJIT' },
                        diagnostics = { 
                            globals = {'vim'},
                            disable = {'lowercase-global'}
                        },
                        workspace = { 
                            library = vim.api.nvim_get_runtime_file("", true),
                            checkThirdParty = false,
                        },
                        telemetry = { enable = false },
                    },
                },
                single_file_support = true,
                on_attach = function(client, bufnr)
                    print('[INFO] Lua LSP attached to buffer ' .. bufnr)
                end,
            })
        end)
        
        if lua_ok then
            print('[SUCCESS] Lua LSP configured')
        else
            print('[WARNING] Failed to configure Lua LSP: ' .. tostring(lua_err))
        end
    else
        print('[INFO] lua-language-server not found, skipping Lua LSP')
    end
    
    -- Go LSP removed for simplicity
end

-- Set up LSP with error handling
local lsp_ok, lsp_err = pcall(setup_lsp)
if not lsp_ok then
    print('[ERROR] LSP setup failed: ' .. tostring(lsp_err))
end

print('[INFO] Test environment initialized')
EOF
    
    if [ ! -f "$init_file" ]; then
        print_error "Failed to create test init file"
        exit 1
    fi
    
    echo "$init_file"
}

# Run a test file with real Neovim and comprehensive error handling
run_test() {
    local test_file=$1
    local test_name
    test_name=$(basename "$test_file" .lua)
    
    print_info "Running $test_name..."
    
    # Validate test file exists and is readable
    if [ ! -f "$test_file" ]; then
        print_error "Test file not found: $test_file"
        return 1
    fi
    
    if [ ! -r "$test_file" ]; then
        print_error "Test file not readable: $test_file"
        return 1
    fi
    
    # Create test init file
    local init_file
    init_file=$(create_test_init)
    
    # Ensure cleanup happens even if test fails
    trap "rm -f '$init_file'" EXIT
    
    # Run test in headless Neovim with comprehensive error capture
    local exit_code=0
    local test_output
    local test_error
    
    # Capture both stdout and stderr separately
    {
        test_output=$(nvim --headless --noplugin -u "$init_file" \
            -c "lua package.path = package.path .. ';$PROJECT_ROOT/lua/?.lua;$PROJECT_ROOT/lua/?/init.lua'" \
            -c "lua dofile('$test_file')" \
            -c "qa!" 2>&1)
        exit_code=$?
    } || {
        exit_code=$?
        test_error="Neovim execution failed with exit code $exit_code"
    }
    
    # Clean up init file
    rm -f "$init_file"
    trap - EXIT
    
    # Process results
    if [ $exit_code -eq 0 ]; then
        print_success "$test_name completed"
        
        # Show any important output (warnings, info)
        if [[ -n "$test_output" ]]; then
            echo "$test_output" | while IFS= read -r line; do
                if [[ "$line" =~ ^\[WARNING\] ]] || [[ "$line" =~ ^\[INFO\] ]]; then
                    print_info "  $line"
                fi
            done
        fi
        
        return 0
    else
        print_error "$test_name failed (exit code: $exit_code)"
        
        # Show error output
        if [[ -n "$test_output" ]]; then
            print_error "Test output:"
            echo "$test_output" | sed 's/^/    /' # Indent output
        fi
        
        if [[ -n "$test_error" ]]; then
            print_error "Additional error: $test_error"
        fi
        
        return $exit_code
    fi
}

# Create a simple environment test if integration tests are missing
create_simple_test() {
    local simple_test_file="$SCRIPT_DIR/simple_env_test.lua"
    
    cat > "$simple_test_file" << 'EOF'
-- Simple environment test - auto-generated
local colors = {
  reset = '\27[0m',
  green = '\27[32m',
  blue = '\27[34m',
}

local function print_status(color, prefix, message)
  print(string.format('%s[%s]%s %s', color, prefix, colors.reset, message))
end

print_status(colors.blue, 'TEST', 'Testing real environment setup...')

-- Test basic Neovim functionality
local bufnr = vim.api.nvim_create_buf(false, true)
if bufnr == 0 then
  error('Failed to create test buffer')
end

print_status(colors.green, 'SUCCESS', 'Created test buffer: ' .. bufnr)

-- Test plugin loading
local ok, position = pcall(require, 'hoverfloat.core.position')
if not ok then
  error('Failed to load hoverfloat.core.position: ' .. tostring(position))
end

print_status(colors.green, 'SUCCESS', 'Loaded hoverfloat.core.position module')

-- Test basic functionality
local context_ok, context = pcall(position.get_current_context)
if not context_ok then
  error('Failed to get current context: ' .. tostring(context))
end

print_status(colors.green, 'SUCCESS', 'Got current context: ' .. context.file .. ':' .. context.line)

print_status(colors.green, 'SUCCESS', 'Environment test passed!')
EOF
    
    echo "$simple_test_file"
}

# Main test runner
main() {
    print_info "Real Neovim Test Runner for hoverfloat"
    print_info "====================================="
    
    check_prerequisites
    
    # Find test files with fallback options
    local test_files=()
    
    # Priority 1: Integration tests if available
    if [ -f "$SCRIPT_DIR/real_integration_tests.lua" ]; then
        test_files+=("$SCRIPT_DIR/real_integration_tests.lua")
        print_info "Found integration tests"
    fi
    
    # Priority 2: Unit tests
    if [ -f "$SCRIPT_DIR/real_unit_tests.lua" ]; then
        test_files+=("$SCRIPT_DIR/real_unit_tests.lua")
        print_info "Found unit tests"
    fi
    
    # Priority 3: Create simple environment test if no others exist
    if [ ${#test_files[@]} -eq 0 ] && [ -f "$SCRIPT_DIR/test_env.lua" ]; then
        local simple_test
        simple_test=$(create_simple_test)
        test_files+=("$simple_test")
        print_info "Created simple environment test"
    fi
    
    # Validate we have tests to run
    if [ ${#test_files[@]} -eq 0 ]; then
        print_error "No test files found"
        print_info "Expected files:"
        print_info "  • $SCRIPT_DIR/real_integration_tests.lua"
        print_info "  • $SCRIPT_DIR/real_unit_tests.lua"
        print_info "  • $SCRIPT_DIR/test_env.lua"
        exit 1
    fi
    
    print_info "Running ${#test_files[@]} test file(s)..."
    echo
    
    # Run tests with error tracking
    local total_tests=0
    local failed_tests=0
    
    for test_file in "${test_files[@]}"; do
        total_tests=$((total_tests + 1))
        
        if ! run_test "$test_file"; then
            failed_tests=$((failed_tests + 1))
        fi
        echo
    done
    
    # Clean up any generated test files
    rm -f "$SCRIPT_DIR/simple_env_test.lua"
    
    # Summary
    print_info "====================================="
    print_info "TEST SUMMARY"
    print_info "====================================="
    print_info "Total test files: $total_tests"
    
    if [ $failed_tests -eq 0 ]; then
        print_success "All tests passed!"
        exit 0
    else
        print_error "$failed_tests out of $total_tests test files failed"
        print_info "Check the error output above for details"
        exit 1
    fi
}

# Error handling for the script itself
trap 'print_error "Script interrupted"; exit 130' INT
trap 'print_error "Script terminated"; exit 143' TERM

# Run main function
main "$@"
